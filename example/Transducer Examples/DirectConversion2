import random
from sequence.kernel.timeline import Timeline
from sequence.components.optical_channel import QuantumChannel
from sequence.components.detector import Detector
from sequence.protocol import Protocol
from sequence.topology.node import Node
from sequence.components.light_source import LightSource
from sequence.utils.encoding import absorptive, single_atom
from sequence.components.photon import Photon
from sequence.kernel.entity import Entity
from typing import List, Callable, TYPE_CHECKING
from abc import ABC, abstractmethod
from sequence.components.memory import Memory
from sequence.utils.encoding import fock
import math
from sequence.kernel.event import Event
from sequence.kernel.process import Process
import sequence.utils.log as log
import matplotlib.pyplot as plt

#GENERAL

NUM_TRIALS = 20
FREQUENCY = 1e9
MICROWAVE_WAVELENGTH = 999308 # nm
OPTICAL_WAVELENGTH = 1550 # nm

# Timeline
START_TIME = 0
CONVERSION_DURATION = 1 # ps
PERIOD = CONVERSION_DURATION + CONVERSION_DURATION

# Source
MEAN_PHOTON_NUM = 10

# Transducer
EFFICIENCY_UP = 0.5
EFFICIENCY_DOWN = 0.8

# Fock Detector
MICROWAVE_DETECTOR_EFFICIENCY_Rx = 1
MICROWAVE_DETECTOR_EFFICIENCY_Tx = 1
OPTICAL_DETECTOR_EFFICIENCY = 1

# Channel
ATTENUATION = 0
DISTANCE = 1e3



#ENTITIES

class FockDetector(Detector):
    def __init__(self, name: str, timeline: "Timeline", efficiency=1, wavelength=int, encoding_type=fock):
        super().__init__(name, timeline, efficiency)
        self.name = name
        self.photon_counter = 0
        self.wavelength = wavelength
        self.encoding_type = encoding_type
        self.timeline = timeline
        self.efficiency = efficiency
    
    def init(self):
        pass

    def get(self, photon=None, **kwargs) -> None:
        if random.random() < self.efficiency:
            self.photon_counter += 1
    
    def receive_photon(self, src: str, photon: "Photon") -> None:
        if photon.wavelength == self.wavelength:
            self.get(photon)
        else:
            pass

class Transducer(Entity):
    def __init__(self, owner: "Node", name: str, timeline: "Timeline", efficiency=1, photon_counter=int):
        Entity.__init__(self, name, timeline)
        self.name = name
        self.owner = owner
        self.timeline = timeline
        self.efficiency = efficiency
        self.photon_counter = 0

    def init(self):
        assert len(self._receivers) == 2

    def add_output(self, outputs: List):
        for i in outputs:
            self.add_receiver(i)
    
    def receive_photon_from_channel(self, photon: "Photon") -> None:
        self.photon_counter += 1


#class Trasmon(Entity):
#    def __init__(self, owner: "Node", name: str, timeline: "Timeline", photon_counter=int):
#        Entity.__init__(self, name, timeline)
#        self.name = name
#        self.owner = owner
#        self.timeline = timeline
#        self.photon_counter = 0

#    def init(self):
#        pass

#   def emit(self, outputs: List):
#       pass
    



#PROTOCOLS


#class EmittingProtocol(Protocol):
#    def __init__(self, own: "Node", name: str, trasmon=Trasmon):
#        super().__init__(own, name)

#    def start(self, state_list) -> None: 
#        trasmon = node1.get_components_by_type("trasmon")[0]
#        #photon = Photon(f"photon", tl)
#        trasmon.emit([state_list[trial]]) 

#    def received_message(self, src: str, msg):
#        pass

    


#nota per questi protocolli: il detector della prima condizione Ã¨ quello che identifica la conversione AVVENUTA :)

class UpConversionProtocol(Protocol):
    def __init__(self, own: "Node", name: str, transducer=Transducer):
        super().__init__(own, name)
        self.owner = own
        self.name = name
        self.transducer = transducer    

    def start(self, photon: "Photon") -> None:
        #transducer = own.get_components_by_type("Transducer")[0]

        if random.random() < self.transducer.efficiency:
            photon.wavelength = OPTICAL_WAVELENGTH    
            self.transducer._receivers[0].receive_photon(node2, photon)
            print("Successful up-conversion")
        else:
            photon.wavelength = MICROWAVE_WAVELENGTH 
            self.transducer._receivers[1].get(photon)
            print("FAILED up-conversion")
  
    def received_message(self, src: str, msg):
        pass


class DownConversionProtocol(Protocol):
    def __init__(self, own: "Node", name: str, transducer=Transducer):
        super().__init__(own, name)    

    def start(self, photon: "Photon") -> None: 
        transducer2 = node2.get_components_by_type("Transducer")[0]
        if transducer2.photon_counter > 0:
            if random.random() < transducer2.efficiency:
                photon.wavelength = MICROWAVE_WAVELENGTH
                transducer2._receivers[0].get(photon) 
                print("Successful down-conversion")
            else:
                photon.wavelength = OPTICAL_WAVELENGTH    
                transducer2._receivers[1].get(photon)
                print("FAILED down-conversion")
        else:
            print("No photon to down-convert")
        
    def received_message(self, src: str, msg):
        pass



class Counter:
    def __init__(self):
        self.count = 0

    def trigger(self, detector, info):
        self.count += 1


class SenderNode(Node):
    def __init__(self, name, timeline, node2):
        super().__init__(name, timeline)

        # Hardware setup

        # istanzio il componente sorgente nel nodo
       # self.trasmon_name = name + ".trasmon"
       # trasmon = Trasmon(name + ".lightsource", timeline, )
        #self.add_component(trasmon)
       # self.set_first_component(self.lightsource_name)
        #trasmon.photon_counter = 0

        self.transducer_name = name + ".transducer"
        transducer = Transducer(name=self.transducer_name, owner=self, timeline=timeline, efficiency=EFFICIENCY_UP)
        self.add_component(transducer)
        transducer.attach(self)
        transducer.photon_counter = 0
        self.counter = Counter()
        transducer.attach(self.counter)
        self.set_first_component(self.transducer_name)

        #lightsource.add_receiver(transducer)


        detector_name = name + ".fockdetector1"
        detector = FockDetector(detector_name, timeline, wavelength=MICROWAVE_WAVELENGTH, efficiency=MICROWAVE_DETECTOR_EFFICIENCY_Tx)
        self.add_component(detector)
        self.set_first_component(detector_name)
        self.counter = Counter()
        detector.attach(self.counter)

        transducer.add_output([node2, detector])

        #self.emitting_protocol = EmittingProtocol(self, name + ".emitting_protocol")
        self.upconversion_protocol = UpConversionProtocol(self, name + ".upconversion_protocol", transducer)

class ReceiverNode(Node):
    def __init__(self, name, timeline):
        super().__init__(name, timeline)

        self.transducer2_name = name + ".transducer2"
        transducer2 = Transducer(name=self.transducer2_name, owner=self, timeline=timeline, efficiency=EFFICIENCY_DOWN)
        self.add_component(transducer2)
        transducer2.attach(self)
        transducer2.photon_counter = 0
        self.counter = Counter()
        transducer2.attach(self.counter)
        self.set_first_component(self.transducer2_name)

        detector_name2 = name + ".fockdetector2"
        detector2 = FockDetector(detector_name2, timeline, wavelength=MICROWAVE_WAVELENGTH, efficiency=MICROWAVE_DETECTOR_EFFICIENCY_Rx)
        self.add_component(detector2)
        self.counter2 = Counter()
        detector2.attach(self.counter2)

        detector3_name = name + ".fockdetector3"
        detector3 = FockDetector(detector3_name, timeline, wavelength=OPTICAL_WAVELENGTH, efficiency=OPTICAL_DETECTOR_EFFICIENCY)
        self.add_component(detector3)
        self.counter3 = Counter()
        detector3.attach(self.counter3)
        
        transducer2.add_output([detector2, detector3])
        self.downconversion_protocol = DownConversionProtocol(self, name + ".downconversion_protocol")

    def receive_photon(self, src, photon):
        self.components[self.transducer2_name].receive_photon_from_channel(photon)


#MAIN

if __name__ == "__main__":

    runtime = 1e12
    tl = Timeline(runtime)
   
    node2 = ReceiverNode("node2", tl)
    node1 = SenderNode("node1", tl, node2)

    qc1 = QuantumChannel("qc.node1.node2", tl, attenuation=ATTENUATION, distance=DISTANCE)
    qc1.set_ends(node1, node2.name)

    if EFFICIENCY_UP >= 0 and EFFICIENCY_UP <= 1 and EFFICIENCY_DOWN >= 0 and EFFICIENCY_DOWN <= 1:
        pass
    else:
        print("Error: the efficiency must be between 0 and 1")
        exit(1)

    state = (0.0 + 0.0j, 1.0 + 0.0j)
    print(f"Fock states emitted by the LightSource: {state}")
    state_list = [state] * NUM_TRIALS

    tl.init()

    total_photons_successful = 0
    
    failed_up_conversions = []
    failed_down_conversions = []
    successful_conversions = [] 
    
    for trial in range(NUM_TRIALS): 

        print(f"--------------------")
        print(f"Trial {trial}:")

        tl.run()


        #lightsource = node1.get_components_by_type("LightSource")[0]
        #lightsource.photon_counter = 0
        #lightsource.emit([state_list[trial]])
        #print(f"Number of photons emitted in trial {trial + 1}: {lightsource.photon_counter}")
        #total_photons_emitted += lightsource.photon_counter

        detector = node1.get_components_by_type("FockDetector")[0]
        detector_count = detector.photon_counter

        transducer2 = node2.get_components_by_type("Transducer")[0]

        detector2 = node2.get_components_by_type("FockDetector")[0]
        detector2_count = detector2.photon_counter
        detector3 = node2.get_components_by_type("FockDetector")[1]
        detector3_count = detector3.photon_counter

        

        #process0 = Process(node1.emitting_protocol, "start", [Photon])
        #event0 = Event(START_TIME * trial, process0)
        #tl.schedule(event0)

        process1 = Process(node1.upconversion_protocol, "start", [Photon])
        event1 = Event(START_TIME + CONVERSION_DURATION * trial, process1)
        tl.schedule(event1)

        process2 = Process(node2.downconversion_protocol, "start", [Photon])
        event2 = Event((START_TIME  + CONVERSION_DURATION) + CONVERSION_DURATION * trial, process2)
        tl.schedule(event2)
        
        failed_up_conversions.append(detector_count)
        failed_down_conversions.append(detector3_count)
        successful_conversions.append(detector2_count)


        print(f"Number of photons converted at time {tl.time}: {detector2_count}") 
        #Chiedere questione tl_now
        
        detector.photon_counter = 0
        detector2.photon_counter = 0
        detector3.photon_counter = 0
        transducer2.photon_counter = 0

        total_photons_successful += detector2_count




    #RESULTS

    print(f"- - - - - - - - - -")

    #Percentuale di fotoni convertiti

    total_photons_to_be_converted = NUM_TRIALS - 1
    print(f"Total number of photons converted: {total_photons_successful}")
    conversion_percentage = (total_photons_successful / total_photons_to_be_converted) * 100 if total_photons_to_be_converted > 0 else 0
    print(f"Conversion efficiency of DQT protocol: {conversion_percentage:.2f}%")

    print(f"- - - - - - - - - -")

    #Plot dell'andamento delle conversioni rispetto al numero di trials
    trials = list(range(NUM_TRIALS))
    plt.plot(trials, failed_up_conversions, label="Failed UpConversions")
    plt.plot(trials, failed_down_conversions, label="Failed DownConversions")
    plt.plot(trials, successful_conversions, label="Successful Conversions")
    plt.xticks(range(0, NUM_TRIALS, 1))  # Mostra le etichette ogni 10 trial

    plt.xlabel("Trial")
    plt.ylabel("Number of Conversions")
    plt.title("Photon Conversion over Trials")
    plt.legend()
    plt.show()

    #Plot rispetto al tempo?
