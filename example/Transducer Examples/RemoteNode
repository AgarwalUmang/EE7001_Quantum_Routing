import random
from sequence.kernel.timeline import Timeline
from sequence.components.optical_channel import QuantumChannel
from sequence.components.detector import Detector
from sequence.protocol import Protocol
from sequence.topology.node import Node
from sequence.components.light_source import LightSource
from sequence.utils.encoding import absorptive, single_atom
from sequence.components.photon import Photon
from sequence.kernel.entity import Entity
from typing import List, Callable, TYPE_CHECKING
from abc import ABC, abstractmethod
from sequence.components.memory import Memory
from sequence.utils.encoding import fock
import math
from sequence.kernel.event import Event
from sequence.kernel.process import Process

import sequence.utils.log as log
import matplotlib.pyplot as plt

# General
NUM_TRIALS = 5
FREQUENCY = 1e9
START_TIME = 0
PERIOD = int(1e12 / FREQUENCY)

# Source
WAVELENGTH = 1550
MEAN_PHOTON_NUM = 10

# Transducer
EFFICIENCY_UP = 0.5
EFFICIENCY_DOWN = 0.5

# Fock Detector
MICROWAVE_DETECTOR_EFFICIENCY_Rx = 1
MICROWAVE_DETECTOR_EFFICIENCY_Tx = 1
OPTICAL_DETECTOR_EFFICIENCY = 1

# Channel
ATTENUATION = 0
DISTANCE = 1e3

#ENTITIES

class Counter:
    def __init__(self):
        self.count = 0

    def trigger(self, detector, info):
        self.count += 1


class FockDetector(Detector):
    def __init__(self, name: str, timeline: "Timeline", efficiency=1, wavelength=1550, encoding_type=fock):
        super().__init__(name, timeline, efficiency)
        self.name = name
        self.photon_counter = 0
        self.wavelength = wavelength
        self.encoding_type = encoding_type
        self.timeline = timeline
        self.efficiency = efficiency
    
    def init(self):
        pass

    def get(self, photon=None, **kwargs) -> None:
        if random.random() < self.efficiency:
            self.photon_counter += 1



class Transducer(Entity):
    def __init__(self, owner: "Node", name: str, timeline: "Timeline", efficiency=1):
        Entity.__init__(self, name, timeline)
        self.name = name
        self.owner = owner
        self.timeline = timeline
        self.efficiency = efficiency

    def init(self):
        assert len(self._receivers) == 2

    def add_output(self, outputs: List):
        for i in outputs:
            self.add_receiver(i)

   
#PROTOCOLS

class UpConversionProtocol(Protocol):
    def __init__(self, own: "Node", name: str, transducer=Transducer):
        super().__init__(own, name)    

    def start(self) -> None:
        transducer = node1.get_components_by_type("Transducer")[0]
        print(transducer._receivers[0])
        if random.random() < transducer.efficiency:
            print("Successful conversion")
            photon = Photon(f"photon", tl)
            transducer._receivers[0].receive_photon(node2, photon)
        else:
            print("NO successful conversion")
            photon = Photon(f"photon", tl)
            transducer._receivers[1].get(photon)

    def received_message(self, src: str, msg):
        pass



class DownConversionProtocol(Protocol):
    def __init__(self, own: "Node", name: str, transducer=Transducer):
        super().__init__(own, name)    

    def start(self, photon: "Photon") -> None: 
        transducer = node2.get_components_by_type("Transducer")[0]
      
        if random.random() < transducer.efficiency:
                print("Successful down-conversion")
                
                transducer._receivers[0].get(photon)
        else:
                print("NO successful down-conversion")
                transducer._receivers[1].get(photon)

    def received_message(self, src: str, msg):
        pass


class EmittingProtocol(Protocol):
    def __init__(self, own: "Node", name: str, lighsource=LightSource):
        super().__init__(own, name)    

    def start(self, photon: "Photon") -> None: 
        lighsource = node1.get_components_by_type("LightSource")[0]
        photon = Photon(f"photon", tl)
        lighsource.emit(node1, photon)
        

    def received_message(self, src: str, msg):
        pass

#NODES

class SenderNode(Node):
    def __init__(self, name, timeline, node2):
        super().__init__(name, timeline)

        # Hardware setup

        #Istanzio componenet trasduttore
        self.transducer_name = name + ".transducer"
        transducer = Transducer(name=self.transducer_name, owner=self, timeline=timeline, efficiency=EFFICIENCY_UP)
        self.add_component(transducer)
        transducer.attach(self)
        transducer.photon_counter = 0
        self.counter = Counter()
        transducer.attach(self.counter)
        self.set_first_component(self.transducer_name)

        #Istanzio componente microwave detector nel Tx
        detector_name = name + ".fockdetector1"
        detector = FockDetector(detector_name, timeline, efficiency=MICROWAVE_DETECTOR_EFFICIENCY_Tx)
        self.add_component(detector)
        self.set_first_component(detector_name)
        self.counter = Counter()
        detector.attach(self.counter)

        #output del trasduttore
        transducer.add_output([node2, detector])

        #Istanzio il protocollo di upconversion
        self.upconversion_protocol = UpConversionProtocol(self, name + ".upconversion_protocol")



class ReceiverNode(Node):  # nodo con il tradsuttore (che dovrebbe ricevere fisicamente il fotone) e un detector
    def __init__(self, name, timeline):  # espliciti l'owner
        super().__init__(name, timeline)  # passare oggetto

    
        detector2_name = name + ".fockdetector2"
        detector2 = FockDetector(detector2_name, timeline, efficiency=OPTICAL_DETECTOR_EFFICIENCY)
        self.add_component(detector2)


        self.set_first_component(detector2_name)
        
        self.counter2 = Counter()
        detector2.attach(self.counter2)
        #print(detector2.photon_counter)

    def receive_photon(self, src, photon: "Photon") -> None: #semplificata (senza sorgente)
        self.components[self.first_component_name].get(photon)

        #transducer.add_output([detector2, detector3])
        #self.downconversion_protocol = DownConversionProtocol(self, name + ".downconversion_protocol")

    
if __name__ == "__main__":

    runtime = 1e12
    tl = Timeline(runtime)
   
    node2 = ReceiverNode("node2", tl)
    node1 = SenderNode("node1", tl, node2)

    qc1 = QuantumChannel("qc.node1.node2", tl, attenuation=ATTENUATION, distance=DISTANCE)
    qc1.set_ends(node1, node2.name)

    if EFFICIENCY_UP >= 0 and EFFICIENCY_DOWN >= 0:
        pass
    else:
        print("Error: the efficiency must be between 0 and 1")
        exit(1)
   


    tl.init()

    print(f"--------------------")

    for trial in range(NUM_TRIALS): 
        print(f"Trial {trial+1}:")


        tl.run() #se metto qua il tl.run il primo trial non richiama la funzione, ho sempre 0 e 0

        detector = node1.get_components_by_type("FockDetector")[0]
        detector_count = detector.photon_counter
        detector2 = node2.get_components_by_type("FockDetector")[0]
        detector2_count = detector2.photon_counter

        process = Process(node1.upconversion_protocol, "start", [])
        event = Event(START_TIME + PERIOD * trial, process)
        tl.schedule(event)

        
        #print(f"Number of photons converted at time {tl.time} ps: {detector2_count}") #sistema queste unità di misura
        #print(f"Number of NOT converted photons at time {tl.time} ps: {detector_count}")

        #tl.run() #se metto qua il tl.run mi "scala" nel tempo i fotoni ricevuti da detector e detector2
    
    
        print(f"Number of photons converted at time {tl.time} ps: {detector2_count}") #sistema queste unità di misura
        print(f"Number of NOT converted photons at time {tl.time} ps: {detector_count}")

        #reset dei detector
        detector.photon_counter = 0
        detector2.photon_counter = 0
      
    print(f"--------------------")
